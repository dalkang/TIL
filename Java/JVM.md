# Java

## JVM(Java Virtual Machine)

>  자바 바이트 코드를 실행시키기 위한 가상의 기계

### JVM 구성

* `Java Interpreter` : 자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석
* `Class Loader` : 런타임일 때 동적으로 클래스를 로딩
* `JIT Compiler` : 런타임일 때 기계어로 변환해주는 컴파일러
* `Garbage Collector` : 사용하지 않는 메모리 자동으로 회수

### 메모리 영역(Runtime Data Area)

> 프로그램 실행 > JVM 구동 > OS로부터 메모리 영역(Runtime Data Area) 할당

* `메소드 영역` : JVM 시작할 때 생성
  * 모든 스레드가 공유
  * 로딩된 **클래스 바이트 코드**의 내용을 분석 후 저장
    * 자바 컴파일러가 자바 소스 코드를 자바 바이트 코드로 변환
    * 자바 바이트 코드 확장자 `.class`
* `힙 영역` : JVM을 시작할 때 생성
  * **객체/배열** 저장
  * 사용되지 않는 객체/배열은 Garbage Collector가 자동 회수
* `JVM 스택` : 스레드별로 생성
  * 메소드를 호출할 때마다 Frame을 스택에 추가, **변수 생성**
  * 메소드를 종료하면 Frame 제거, **변수도 함께 삭제**

### 메모리 사용 순서

1. **java 실행 파일**
   * 운영체제로부터 실행 파일의 메모리 영역을 할당받음
2. **JVM 구동**
   * 운영체제에서 받은 메모리 영역(Runtime Data Area) 생성
   * 메소드, 힙 영역 생성
3. **실행 파일의 클래스 로딩**
   * 바이트 코드 로딩
   * 메소드 영역에 분석된 클래스의 내용 저장
4. **main 스레드 생성**
   * main 메소드를 실행시키는 스레드 생성
   * JVM 스택 생성
5. **main 메소드 호출**
   * JVM 프레임 생성
6. **main 메소드 실행**
   * 메소드의 매개변수가 스택 프레임 내부에 생성
   * 객체/배열은 힙 영역에 생성
   * 스택 프레임 내부에 있는 참조변수는 주소를 통해 힙 영역에 있는 객체/배열 참조
7. **코드를 순차적으로 실행하며 JVM 스택 내부 프레임에서 연산**
   * 메소드를 호출할 경우 새로운 프레임 생성, 해당 프레임 내부에서 연산 후 메소드가 끝나면 프레임 소멸
8. **main 메소드 종료**
   * main 메소드가 호출될 때 만들어졌던 힙 영역의 객체/배열,  JVM 스택 프레임 소멸
9. **JVM 구동 종료**

